/***
    URL module
    From: 0.1.2
    Minimal version: 0.1.2
**/


method parseUrl(url: string): URL {
    urlRegex = regexMatch("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?", url)
    return :URL(urlRegex[2], urlRegex[4], urlRegex[5], urlRegex[7], urlRegex[9])
}

class URL(scheme  : string,
            host  : ?string,
            path  : ?string,
            query : ?string,
            hash  : ?string) {
    method openConnection(): ?Connection {
        hostParts = []
        if host!=null: hostParts = host.split(':')

        if scheme=="http": {
            return :HTTPConnection(:Socket(hostParts[0], :int(hostParts[1] ?: 80)), this)
        }else if scheme=="https": {
            return :HTTPConnection(:Socket(hostParts[0], :int(hostParts[1] ?: 443)), this)
        }else if scheme=="file": {
            return :Connection(-> (connection: Connection) {
                file = :File(path)
                connection.output = file.openOutput()
                connection.input = file.openInput()
            })
        }

        return null
    }

    method getFullPath(): string {
        fullPath = ""
        if path!=null: fullPath += path
        if query!=null: fullPath += "?" + query
        if hash!=null: fullPath += "#" + hash

        return fullPath
    }

    method toString(): string {
        url = scheme + "://"
        if host!=null: url += host

        return url + getFullPath()
    }
}

class HTTPConnection(socket: Socket, url: URL) extends Connection {
    headers = [
        "Host: "+url.host
    ]

    method connect() {
        output = socket.output
        input = socket.input

        socket.output.println("GET "+url.getFullPath()+" HTTP/1.1")
        headers.forEach(-> (header) socket.output.println(header))
        socket.output.println("")
        socket.output.flush()
    }
}

class Connection {
    output = null
    input = null

    method connect() {
        printError("this is abstract class xD")
    }
}